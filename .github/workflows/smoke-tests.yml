name: DE_Portal test Report

on:
  schedule:
    - cron: "30 3 * * 1-5"   # 9:00 AM IST, Monday‚ÄìFriday
  workflow_dispatch:

jobs:
  smoke:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Cache Playwright browsers
        uses: actions/cache@v3
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-

      - name: Install Playwright browsers
        run: npx playwright install --with-deps

      - name: Install additional tools
        run: sudo apt-get update && sudo apt-get install -y curl

      - name: Run Playwright smoke tests with HTML + JSON report
        id: tests
        continue-on-error: true
        run: |
          mkdir -p reports
          ts=$(date +'%Y-%m-%d_%H-%M-%S')
          
          # Run tests with explicit JSON reporter
          npx playwright test --grep @smoke 
          
          # Move HTML report
          if [ -d "playwright-report" ]; then
            mv playwright-report "reports/$ts"
          else
            mkdir -p "reports/$ts"
            echo "No HTML report generated" > "reports/$ts/index.html"
          fi
          
          # Copy JSON results
          if [ -f "test-results/results.json" ]; then
            cp "test-results/results.json" "reports/$ts/results.json"
            echo "‚úÖ Found results.json"
          else
            echo "‚ùå No results.json file found - creating a detailed fallback file"
            # Create a more detailed fallback result file with proper structure for failed tests (single line JSON to avoid YAML parsing issues)
            echo '{"stats":{"expected":0,"unexpected":1,"flaky":0,"skipped":0,"duration":30000},"suites":[{"title":"Test Execution","suites":[{"title":"Smoke Tests","specs":[{"title":"Test execution process","ok":false,"tests":[{"title":"Smoke test execution","ok":false,"results":[{"status":"failed","errors":[{"message":"Test execution failed. No results.json file was generated. Check workflow logs for details."}]}]}]}]}]}]}' > "reports/$ts/results.json"
            echo "‚úÖ Created detailed fallback results.json with proper test structure"
          fi
          
          echo "REPORT_TS=$ts" >> $GITHUB_ENV

      - name: Deploy Playwright reports to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        if: always()
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./reports
          publish_branch: gh-pages
          keep_files: true

      - name: Install and test Teams notification system
        run: |
          # Install the dynamic Teams notification system
          echo "Installing Teams notification dependencies..."
          
      - name: Parse results and send dynamic Teams notification
        if: always()
        run: |
          # Ensure REPORT_TS exists and is not empty, otherwise set a fallback
          if [ -z "$REPORT_TS" ]; then
            echo "‚ö†Ô∏è Warning: REPORT_TS is not set. Using current timestamp as fallback."
            REPORT_TS=$(date +'%Y-%m-%d_%H-%M-%S')
            echo "REPORT_TS=$REPORT_TS" >> $GITHUB_ENV
          fi
          
          RESULTS_FILE="reports/$REPORT_TS/results.json"
          REPORT_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/$REPORT_TS/"
          
          # Verify paths for debugging
          echo "üìä Results file path: $RESULTS_FILE"
          echo "üîó Report URL: $REPORT_URL"
          
          # Check if results directory exists, create if not
          if [ ! -d "reports/$REPORT_TS" ]; then
            echo "‚ö†Ô∏è Creating missing reports directory: reports/$REPORT_TS"
            mkdir -p "reports/$REPORT_TS"
          fi
          
          # Check if results file exists, create fallback if not
          if [ ! -f "$RESULTS_FILE" ]; then
            echo "‚ö†Ô∏è Results file not found, creating fallback file"
            echo '{"stats":{"expected":0,"unexpected":1,"flaky":0,"skipped":0,"duration":30000},"suites":[{"title":"Test Execution","suites":[{"title":"Smoke Tests","specs":[{"title":"Test execution process","ok":false,"tests":[{"title":"Smoke test execution","ok":false,"results":[{"status":"failed","errors":[{"message":"Test execution failed. Results file not found or inaccessible."}]}]}]}]}]}]}' > "$RESULTS_FILE"
            echo "‚úÖ Created fallback results file at $RESULTS_FILE"
          fi
          
          # Use the new Node.js Teams notification script
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          
          class TeamsNotifier {
            constructor(webhookUrl, options = {}) {
              this.webhookUrl = webhookUrl;
              this.options = {
                repositoryName: options.repositoryName || 'DE_portal-Automation',
                repositoryOwner: options.repositoryOwner || 'ng-navaneetha',
                runId: options.runId || process.env.GITHUB_RUN_ID || 'unknown',
                reportUrl: options.reportUrl || null,
                sender: options.sender || 'ng-navaneetha',
                timezone: options.timezone || 'Asia/Kolkata',
                ...options
              };
            }
            
            parseResults(resultsFilePath) {
              try {
                if (!fs.existsSync(resultsFilePath)) {
                  throw new Error(`Results file not found: ${resultsFilePath}`);
                }
                
                const rawData = fs.readFileSync(resultsFilePath, 'utf8');
                const data = JSON.parse(rawData);
                
                const stats = data.stats || {};
                const summary = {
                  total: (stats.expected || 0) + (stats.unexpected || 0) + (stats.flaky || 0) + (stats.skipped || 0),
                  passed: stats.expected || 0,
                  failed: stats.unexpected || 0,
                  flaky: stats.flaky || 0,
                  skipped: stats.skipped || 0,
                  duration: stats.duration || 0,
                  startTime: stats.startTime || new Date().toISOString()
                };
                
                const testDetails = this.extractTestDetails(data);
                const failedTests = this.extractFailedTests(data);
                
                return {
                  summary,
                  testDetails,
                  failedTests,
                  hasRealData: summary.total > 0
                };
                
              } catch (error) {
                console.error('Error parsing results:', error.message);
                return {
                  summary: { total: 0, passed: 0, failed: 1, flaky: 0, skipped: 0, duration: 0 },
                  testDetails: [],
                  failedTests: [],
                  hasRealData: false,
                  error: error.message
                };
              }
            }
            
            extractTestDetails(data) {
              const tests = [];
              
              const extractFromSuite = (suite) => {
                if (suite.specs && Array.isArray(suite.specs)) {
                  suite.specs.forEach(spec => {
                    const test = spec.tests?.[0];
                    const result = test?.results?.[0];
                    const status = result?.status || 'unknown';
                    
                    tests.push({
                      title: spec.title,
                      status: status,
                      duration: result?.duration || 0,
                      file: spec.file || suite.file || '',
                      error: result?.errors?.[0]?.message || null
                    });
                  });
                }
                
                if (suite.suites && Array.isArray(suite.suites)) {
                  suite.suites.forEach(extractFromSuite);
                }
              };
              
              if (data.suites && Array.isArray(data.suites)) {
                data.suites.forEach(extractFromSuite);
              }
              
              return tests;
            }
            
            extractFailedTests(data) {
              const allTests = this.extractTestDetails(data);
              return allTests.filter(test => test.status !== 'passed' && test.status !== 'skipped');
            }
            
            formatDuration(milliseconds) {
              const seconds = Math.floor(milliseconds / 1000);
              const minutes = Math.floor(seconds / 60);
              
              if (minutes > 0) {
                return `${minutes}m ${seconds % 60}s`;
              }
              return `${seconds}s`;
            }
            
            getCurrentTime() {
              const now = new Date();
              return now.toLocaleString('en-IN', {
                timeZone: this.options.timezone,
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
              }) + ' IST';
            }
            
            generateMessage(results) {
              const { summary, testDetails, failedTests, hasRealData, error } = results;
              
              if (!hasRealData || error) {
                // Even with errors, create a structured message with more details
                let reportSection = '';
                if (this.options.reportUrl) {
                  reportSection = `\\nüìë [View Full Report](${this.options.reportUrl})`;
                }
                
                return {
                  text: `üö® **DE_Portal Test Results**\\n\\n‚ùå Test execution failed${error ? ` - ${error}` : ' - no results available'}\\n\\nÔøΩ **Summary:**\\n‚Ä¢ Total: 1 test\\n‚Ä¢ Passed: 0\\n‚Ä¢ Failed: 1\\n‚Ä¢ Duration: Unknown\\n\\nüìã **Test Details:**\\n‚Ä¢ Test execution process ‚ùå\\n\\n**‚ùå Failed Tests:**\\n‚Ä¢ Smoke test execution (failed)\\n  Error: No test results were available. Check workflow logs for details.${reportSection}\\nüîó [View Workflow](https://github.com/${this.options.repositoryOwner}/${this.options.repositoryName}/actions/runs/${this.options.runId})\\n\\n---\\nüë§ **Sent by:** ${this.options.sender} | üïê **Time:** ${this.getCurrentTime()}`
                };
              }
              
              let status, emoji;
              if (summary.failed === 0 && summary.flaky === 0) {
                status = "‚úÖ All Tests Passed";
                emoji = "üéâ";
              } else if (summary.failed > 0) {
                status = "‚ùå Tests Failed";
                emoji = "üö®";
              } else {
                status = "‚ö†Ô∏è Flaky Tests Detected";
                emoji = "‚ö†Ô∏è";
              }
              
              const testSummary = testDetails.slice(0, 10).map(test => {
                const statusIcon = {
                  'passed': '‚úÖ',
                  'failed': '‚ùå',
                  'flaky': '‚ö†Ô∏è',
                  'skipped': '‚è≠Ô∏è',
                  'timedOut': '‚è±Ô∏è'
                }[test.status] || '‚ùì';
                
                const shortTitle = test.title.length > 60 ? test.title.substring(0, 60) + '...' : test.title;
                return `‚Ä¢ ${shortTitle} ${statusIcon}`;
              }).join('\\\\n');
              
              let failedSection = '';
              if (failedTests.length > 0) {
                const failedSummary = failedTests.slice(0, 5).map(test => {
                  const shortTitle = test.title.length > 50 ? test.title.substring(0, 50) + '...' : test.title;
                  return `‚Ä¢ ${shortTitle} (${test.status})`;
                }).join('\\\\n');
                
                failedSection = `\\\\n\\\\n**‚ùå Failed/Flaky Tests:**\\\\n${failedSummary}`;
                
                if (failedTests.length > 5) {
                  failedSection += `\\\\n‚Ä¢ ... and ${failedTests.length - 5} more failed tests`;
                }
              }
              
              let reportSection = '';
              if (this.options.reportUrl) {
                reportSection = `\\\\nüìë [View Full Report](${this.options.reportUrl})`;
              }
              
              const message = `${emoji} **DE_Portal Test Results**\\\\n\\\\n**${status}**\\\\n\\\\nüìä **Summary:**\\\\n‚Ä¢ Total: ${summary.total} tests\\\\n‚Ä¢ Passed: ${summary.passed}\\\\n‚Ä¢ Failed: ${summary.failed}\\\\n‚Ä¢ Flaky: ${summary.flaky}\\\\n‚Ä¢ Skipped: ${summary.skipped}\\\\n‚Ä¢ Duration: ${this.formatDuration(summary.duration)}\\\\n\\\\nüìã **Test Details:**\\\\n${testSummary}${failedSection}${reportSection}\\\\nüîó [View Workflow](https://github.com/${this.options.repositoryOwner}/${this.options.repositoryName}/actions/runs/${this.options.runId})\\\\n\\\\n---\\\\nüë§ **Sent by:** ${this.options.sender} | üïê **Time:** ${this.getCurrentTime()}`;
              
              return { text: message };
            }
            
            async sendToTeams(message) {
              return new Promise((resolve, reject) => {
                const url = new URL(this.webhookUrl);
                const postData = JSON.stringify(message);
                
                const options = {
                  hostname: url.hostname,
                  port: url.port || 443,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(postData)
                  }
                };
                
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                      console.log('‚úÖ Teams notification sent successfully');
                      resolve({ success: true, status: res.statusCode, data });
                    } else {
                      reject(new Error(`Teams API returned status ${res.statusCode}: ${data}`));
                    }
                  });
                });
                
                req.on('error', (error) => {
                  reject(new Error(`Failed to send Teams notification: ${error.message}`));
                });
                
                req.write(postData);
                req.end();
              });
            }
            
            async processAndNotify(resultsFilePath) {
              try {
                console.log(`üìä Parsing test results from: ${resultsFilePath}`);
                const results = this.parseResults(resultsFilePath);
                
                console.log(`üìà Summary: ${results.summary.total} total, ${results.summary.passed} passed, ${results.summary.failed} failed, ${results.summary.flaky} flaky`);
                
                const message = this.generateMessage(results);
                
                console.log('üì§ Sending Teams notification...');
                await this.sendToTeams(message);
                
                return results;
              } catch (error) {
                console.error('‚ùå Error processing results:', error.message);
                
                const errorMessage = {
                  text: `üö® **DE_Portal Test Results**\\\\n\\\\n‚ùå Error processing test results: ${error.message}\\\\nüïê Time: ${this.getCurrentTime()}\\\\nüîó [View Workflow](https://github.com/${this.options.repositoryOwner}/${this.options.repositoryName}/actions/runs/${this.options.runId})\\\\n\\\\n---\\\\nüë§ **Sent by:** ${this.options.sender}`
                };
                
                try {
                  await this.sendToTeams(errorMessage);
                } catch (sendError) {
                  console.error('‚ùå Failed to send error notification:', sendError.message);
                }
                
                throw error;
              }
            }
          }
          
          // Main execution
          async function main() {
            const webhookUrl = process.env.TEAMS_WEBHOOK_URL;
            const resultsFile = process.env.RESULTS_FILE;
            const reportUrl = process.env.REPORT_URL;
            
            if (!webhookUrl) {
              console.error('‚ùå Teams webhook URL is required');
              process.exit(1);
            }
            
            const notifier = new TeamsNotifier(webhookUrl, {
              repositoryName: 'DE_portal-Automation',
              repositoryOwner: 'ng-navaneetha',
              runId: process.env.GITHUB_RUN_ID,
              reportUrl: reportUrl,
              sender: 'ng-navaneetha'
            });
            
            try {
              await notifier.processAndNotify(resultsFile);
              console.log('‚úÖ Notification process completed successfully');
              process.exit(0);
            } catch (error) {
              console.error('‚ùå Notification process failed:', error.message);
              process.exit(1);
            }
          }
          
          main();
          EOF
        env:
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
          RESULTS_FILE: $RESULTS_FILE
          REPORT_URL: $REPORT_URL
          GITHUB_RUN_ID: ${{ github.run_id }}


            