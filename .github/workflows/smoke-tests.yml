name: DE_Portal test Report

on:
  schedule:
    - cron: "30 3 * * 1-5"   # 9:00 AM IST, Monday‚ÄìFriday
  workflow_dispatch:

jobs:
  smoke:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Cache Playwright browsers
        uses: actions/cache@v3
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-

      - name: Install Playwright browsers
        run: npx playwright install --with-deps

      - name: Install additional tools
        run: sudo apt-get update && sudo apt-get install -y curl

      - name: Run Playwright smoke tests with HTML + JSON report
        id: tests
        continue-on-error: true
        run: |
          mkdir -p reports
          ts=$(date +'%Y-%m-%d_%H-%M-%S')
          
          # Run tests with explicit JSON reporter
          npx playwright test --grep @smoke 
          
          # Move HTML report
          if [ -d "playwright-report" ]; then
            # Check if the HTML report directory contains index.html
            if [ -f "playwright-report/index.html" ]; then
              # Create timestamp directory
              mkdir -p "reports/$ts"
              # Copy all report files to the timestamp directory
              cp -r playwright-report/* "reports/$ts/"
              echo "‚úÖ Copied Playwright HTML report to reports/$ts/"
            else
              # No index.html found in the report directory
              mkdir -p "reports/$ts"
              echo "<html><body><h1>Playwright Test Report</h1><p>No index.html was found in the report directory.</p></body></html>" > "reports/$ts/index.html"
              # Still copy whatever is in the report directory
              cp -r playwright-report/* "reports/$ts/" 2>/dev/null || echo "No report files to copy"
              echo "‚ö†Ô∏è Created fallback index.html in reports/$ts/"
            fi
          else
            # No report directory found at all
            mkdir -p "reports/$ts"
            echo "<html><body><h1>Playwright Test Report</h1><p>No HTML report was generated. Check workflow logs for details.</p></body></html>" > "reports/$ts/index.html"
            echo "‚ö†Ô∏è Created fallback HTML page in reports/$ts/index.html"
          fi
          
          # Copy JSON results
          if [ -f "test-results/results.json" ]; then
            cp "test-results/results.json" "reports/$ts/results.json"
            echo "‚úÖ Found results.json"
          else
            echo "‚ùå No results.json file found - creating a detailed fallback file"
            # Create a more detailed fallback result file with proper structure for failed tests (single line JSON to avoid YAML parsing issues)
            echo '{"stats":{"expected":0,"unexpected":1,"flaky":0,"skipped":0,"duration":30000},"suites":[{"title":"Test Execution","suites":[{"title":"Smoke Tests","specs":[{"title":"Test execution process","ok":false,"tests":[{"title":"Smoke test execution","ok":false,"results":[{"status":"failed","errors":[{"message":"Test execution failed. No results.json file was generated. Check workflow logs for details."}]}]}]}]}]}]}' > "reports/$ts/results.json"
            echo "‚úÖ Created detailed fallback results.json with proper test structure"
          fi
          
          echo "REPORT_TS=$ts" >> $GITHUB_ENV

      - name: Deploy Playwright reports to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        if: always()
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./reports
          publish_branch: gh-pages
          keep_files: true
          cname: ${{ github.repository_owner }}.github.io
          enable_jekyll: false
          user_name: 'github-actions[bot]'
          user_email: 'github-actions[bot]@users.noreply.github.com'

      - name: Install and test Teams notification system
        run: |
          # Validate that GitHub Pages will serve our report correctly
          echo "Validating GitHub Pages URL structure..."
          
          # Create a simple validation script
          cat > validate-gh-pages.js << 'EOF'
          const https = require('https');
          const url = process.argv[2];
          
          if (!url) {
            console.error('‚ùå No URL provided for validation');
            process.exit(1);
          }
          
          console.log(`üîç Validating GitHub Pages URL structure: ${url}`);
          
          // Validate URL format
          try {
            const parsedUrl = new URL(url);
            console.log(`‚úÖ URL format is valid: ${parsedUrl.href}`);
            console.log(`   ‚Ä¢ Host: ${parsedUrl.hostname}`);
            console.log(`   ‚Ä¢ Path: ${parsedUrl.pathname}`);
          } catch (err) {
            console.error(`‚ùå Invalid URL format: ${err.message}`);
          }
          EOF
          
          # Run validation script
          node validate-gh-pages.js "$REPORT_URL"
          
          echo "Installing Teams notification dependencies..."
          
      - name: Parse results and send dynamic Teams notification
        if: always()
        run: |
          # Ensure REPORT_TS exists and is not empty, otherwise set a fallback
          if [ -z "$REPORT_TS" ]; then
            echo "‚ö†Ô∏è Warning: REPORT_TS is not set. Using current timestamp as fallback."
            REPORT_TS=$(date +'%Y-%m-%d_%H-%M-%S')
            echo "REPORT_TS=$REPORT_TS" >> $GITHUB_ENV
          fi
          
          RESULTS_FILE="reports/$REPORT_TS/results.json"
          # Construct and validate the GitHub Pages URL
          REPO_NAME="${{ github.event.repository.name }}"
          # Remove any special characters that might cause issues in URLs
          CLEAN_REPO_NAME=$(echo "$REPO_NAME" | sed 's/[^a-zA-Z0-9_-]/-/g')
          REPORT_URL="https://${{ github.repository_owner }}.github.io/${CLEAN_REPO_NAME}/$REPORT_TS/"
          
          # Verify paths for debugging
          echo "üìä Results file path: $RESULTS_FILE"
          echo "üîó Report URL: $REPORT_URL"
          echo "üìÅ Repository name: $REPO_NAME (cleaned: $CLEAN_REPO_NAME)"
          
          # Check if index.html exists in the reports directory
          if [ -f "reports/$REPORT_TS/index.html" ]; then
            echo "‚úÖ Verified index.html exists in reports/$REPORT_TS/"
          else
            echo "‚ö†Ô∏è Warning: index.html not found in reports/$REPORT_TS/. Creating a placeholder."
            echo "<html><body><h1>Playwright Test Report</h1><p>Report index not found. This is a placeholder.</p></body></html>" > "reports/$REPORT_TS/index.html"
          fi
          
          # Check if results directory exists, create if not
          if [ ! -d "reports/$REPORT_TS" ]; then
            echo "‚ö†Ô∏è Creating missing reports directory: reports/$REPORT_TS"
            mkdir -p "reports/$REPORT_TS"
          fi
          
          # Check if results file exists, create fallback if not
          if [ ! -f "$RESULTS_FILE" ]; then
            echo "‚ö†Ô∏è Results file not found, creating fallback file"
            echo '{"stats":{"expected":0,"unexpected":1,"flaky":0,"skipped":0,"duration":30000},"suites":[{"title":"Test Execution","suites":[{"title":"Smoke Tests","specs":[{"title":"@smoke TC01: Test execution process","ok":false,"tests":[{"title":"@smoke TC01: Test execution process","ok":false,"results":[{"status":"failed","errors":[{"message":"Test execution failed. Results file not found or inaccessible."}]}]}]}]}]}]}' > "$RESULTS_FILE"
            echo "‚úÖ Created fallback results file at $RESULTS_FILE"
          fi
          
          # Use the new Node.js Teams notification script
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          
          class TeamsNotifier {
            constructor(webhookUrl, options = {}) {
              this.webhookUrl = webhookUrl;
              this.options = {
                repositoryName: options.repositoryName || 'DE_portal-Automation',
                repositoryOwner: options.repositoryOwner || 'ng-navaneetha',
                runId: options.runId || process.env.GITHUB_RUN_ID || 'unknown',
                reportUrl: options.reportUrl || null,
                sender: options.sender || 'ng-navaneetha',
                timezone: options.timezone || 'Asia/Kolkata',
                ...options
              };
            }
            
            parseResults(resultsFilePath) {
              try {
                if (!fs.existsSync(resultsFilePath)) {
                  throw new Error(`Results file not found: ${resultsFilePath}`);
                }
                
                const rawData = fs.readFileSync(resultsFilePath, 'utf8');
                const data = JSON.parse(rawData);
                
                const stats = data.stats || {};
                const summary = {
                  total: (stats.expected || 0) + (stats.unexpected || 0) + (stats.flaky || 0) + (stats.skipped || 0),
                  passed: stats.expected || 0,
                  failed: stats.unexpected || 0,
                  flaky: stats.flaky || 0,
                  skipped: stats.skipped || 0,
                  duration: stats.duration || 0,
                  startTime: stats.startTime || new Date().toISOString()
                };
                
                const testDetails = this.extractTestDetails(data);
                const failedTests = this.extractFailedTests(data);
                
                return {
                  summary,
                  testDetails,
                  failedTests,
                  hasRealData: summary.total > 0
                };
                
              } catch (error) {
                console.error('Error parsing results:', error.message);
                return {
                  summary: { total: 0, passed: 0, failed: 1, flaky: 0, skipped: 0, duration: 0 },
                  testDetails: [],
                  failedTests: [],
                  hasRealData: false,
                  error: error.message
                };
              }
            }
            
            extractTestDetails(data) {
              const tests = [];
              
              const extractFromSuite = (suite) => {
                if (suite.specs && Array.isArray(suite.specs)) {
                  suite.specs.forEach(spec => {
                    const test = spec.tests?.[0];
                    const result = test?.results?.[0];
                    const status = result?.status || 'unknown';
                    
                    tests.push({
                      title: spec.title,
                      status: status,
                      duration: result?.duration || 0,
                      file: spec.file || suite.file || '',
                      error: result?.errors?.[0]?.message || null
                    });
                  });
                }
                
                if (suite.suites && Array.isArray(suite.suites)) {
                  suite.suites.forEach(extractFromSuite);
                }
              };
              
              if (data.suites && Array.isArray(data.suites)) {
                data.suites.forEach(extractFromSuite);
              }
              
              return tests;
            }
            
            extractFailedTests(data) {
              const allTests = this.extractTestDetails(data);
              return allTests.filter(test => test.status !== 'passed' && test.status !== 'skipped');
            }
            
            formatDuration(milliseconds) {
              const seconds = Math.floor(milliseconds / 1000);
              const minutes = Math.floor(seconds / 60);
              
              if (minutes > 0) {
                return `${minutes}m ${seconds % 60}s`;
              }
              return `${seconds}s`;
            }
            
            getCurrentTime() {
              const now = new Date();
              return now.toLocaleString('en-IN', {
                timeZone: this.options.timezone,
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
              }) + ' IST';
            }
            
            generateMessage(results) {
              const { summary, testDetails, failedTests, hasRealData, error } = results;
              
              if (!hasRealData || error) {
                // Even with errors, create a structured message with more details
                let reportSection = '';
                if (this.options.reportUrl) {
                  reportSection = `\\nüìë [View Full Report](${this.options.reportUrl})`;
                }
                
                return {
                  text: `‚ùå\\n Tests Failed\\nüìä Summary: ‚Ä¢ Total: 1 test ‚Ä¢ Passed: 0 ‚Ä¢ Failed: 1 ‚Ä¢ Duration: Unknown\\nüìã Test Details: ‚Ä¢ @smoke TC01: Test execution process ‚Ä¢ @smoke TC02: Results validation\\n‚ùå Failed/Flaky Tests: ‚Ä¢ Test execution process (failed)${reportSection} üîó [View Workflow](https://github.com/${this.options.repositoryOwner}/${this.options.repositoryName}/actions/runs/${this.options.runId})\\n\\nüë§ Sent by: ${this.options.sender} | üïê Time: ${this.getCurrentTime()}`
                };
              }
              
              let status, emoji;
              if (summary.failed === 0 && summary.flaky === 0) {
                status = "‚úÖ All Tests Passed";
                emoji = "üéâ";
              } else if (summary.failed > 0) {
                status = "‚ùå Tests Failed";
                emoji = "üö®";
              } else {
                status = "‚ö†Ô∏è Flaky Tests Detected";
                emoji = "‚ö†Ô∏è";
              }
              
              // Format all test names with @smoke prefix for consistency
              const testSummary = testDetails.slice(0, 15).map(test => {
                // Extract or create a test name with proper format
                let title = test.title || '';
                // Add @smoke prefix if not present
                if (!title.includes('@smoke')) {
                  title = '@smoke ' + title;
                }
                // Format as TC01, TC02, etc. if not already formatted
                if (!title.includes('TC')) {
                  const testNum = (testDetails.indexOf(test) + 1).toString().padStart(2, '0');
                  title = title.replace('@smoke', `@smoke TC${testNum}:`);
                }
                
                const shortTitle = title.length > 60 ? title.substring(0, 60) + '...' : title;
                return `‚Ä¢ ${shortTitle}`;
              }).join(' ');
              
              let failedSection = '';
              if (failedTests.length > 0) {
                const failedSummary = failedTests.slice(0, 8).map(test => {
                  // Extract test name without @smoke prefix for cleaner failed test listing
                  let title = test.title || '';
                  if (title.includes('@smoke')) {
                    title = title.split('@smoke ')[1];
                  }
                  const shortTitle = title.length > 50 ? title.substring(0, 50) + '...' : title;
                  return `‚Ä¢ ${shortTitle}`;
                }).join(' ');
                
                failedSection = `\\n‚ùå Failed/Flaky Tests: ${failedSummary}`;
                
                if (failedTests.length > 8) {
                  failedSection += ` ‚Ä¢ ... and ${failedTests.length - 8} more failed tests`;
                }
              }
              
              let reportSection = '';
              if (this.options.reportUrl) {
                // Ensure the URL ends with a trailing slash and index.html to avoid potential 404 errors
                let reportUrl = this.options.reportUrl;
                if (!reportUrl.endsWith('/')) {
                  reportUrl += '/';
                }
                reportSection = `\\nüìë [View Full Report](${reportUrl})`;
              }
              
              const message = `${emoji}\\n ${status}\\nüìä Summary: ‚Ä¢ Total: ${summary.total} tests ‚Ä¢ Passed: ${summary.passed} ‚Ä¢ Failed: ${summary.failed} ‚Ä¢ Flaky: ${summary.flaky} ‚Ä¢ Skipped: ${summary.skipped} ‚Ä¢ Duration: ${this.formatDuration(summary.duration)}\\nüìã Test Details: ${testSummary}${failedSection}${reportSection} üîó [View Workflow](https://github.com/${this.options.repositoryOwner}/${this.options.repositoryName}/actions/runs/${this.options.runId})\\nüë§ Sent by: ${this.options.sender} | üïê Time: ${this.getCurrentTime()}`;
              
              return { text: message };
            }
            
            async sendToTeams(message) {
              return new Promise((resolve, reject) => {
                const url = new URL(this.webhookUrl);
                const postData = JSON.stringify(message);
                
                const options = {
                  hostname: url.hostname,
                  port: url.port || 443,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(postData)
                  }
                };
                
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                      console.log('‚úÖ Teams notification sent successfully');
                      resolve({ success: true, status: res.statusCode, data });
                    } else {
                      reject(new Error(`Teams API returned status ${res.statusCode}: ${data}`));
                    }
                  });
                });
                
                req.on('error', (error) => {
                  reject(new Error(`Failed to send Teams notification: ${error.message}`));
                });
                
                req.write(postData);
                req.end();
              });
            }
            
            async processAndNotify(resultsFilePath) {
              try {
                console.log(`üìä Parsing test results from: ${resultsFilePath}`);
                const results = this.parseResults(resultsFilePath);
                
                console.log(`üìà Summary: ${results.summary.total} total, ${results.summary.passed} passed, ${results.summary.failed} failed, ${results.summary.flaky} flaky`);
                
                const message = this.generateMessage(results);
                
                console.log('üì§ Sending Teams notification...');
                await this.sendToTeams(message);
                
                return results;
              } catch (error) {
                console.error('‚ùå Error processing results:', error.message);
                
                const errorMessage = {
                  text: `‚ùå\\n Tests Failed\\nÔøΩ Summary: ‚Ä¢ Total: 0 tests ‚Ä¢ Failed: 1 ‚Ä¢ Duration: Unknown\\nüìã Test Details: ‚Ä¢ @smoke TC01: Error Processing Test Results\\n‚ùå Failed/Flaky Tests: ‚Ä¢ Error processing test results: ${error.message}\\nüîó [View Workflow](https://github.com/${this.options.repositoryOwner}/${this.options.repositoryName}/actions/runs/${this.options.runId})\\nüë§ Sent by: ${this.options.sender} | üïê Time: ${this.getCurrentTime()}`
                };
                
                try {
                  await this.sendToTeams(errorMessage);
                } catch (sendError) {
                  console.error('‚ùå Failed to send error notification:', sendError.message);
                }
                
                throw error;
              }
            }
          }
          
          // Main execution
          async function main() {
            const webhookUrl = process.env.TEAMS_WEBHOOK_URL;
            const resultsFile = process.env.RESULTS_FILE;
            const reportUrl = process.env.REPORT_URL;
            
            if (!webhookUrl) {
              console.error('‚ùå Teams webhook URL is required');
              process.exit(1);
            }
            
            const notifier = new TeamsNotifier(webhookUrl, {
              // Use the exact repository name from environment variable
              repositoryName: process.env.GITHUB_REPOSITORY ? process.env.GITHUB_REPOSITORY.split('/')[1] : 'DE_portal-Automation',
              repositoryOwner: process.env.GITHUB_REPOSITORY ? process.env.GITHUB_REPOSITORY.split('/')[0] : 'ng-navaneetha',
              runId: process.env.GITHUB_RUN_ID,
              reportUrl: reportUrl,
              sender: process.env.GITHUB_ACTOR || 'ng-navaneetha'
            });
            
            try {
              await notifier.processAndNotify(resultsFile);
              console.log('‚úÖ Notification process completed successfully');
              process.exit(0);
            } catch (error) {
              console.error('‚ùå Notification process failed:', error.message);
              process.exit(1);
            }
          }
          
          main();
          EOF
        env:
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
          RESULTS_FILE: $RESULTS_FILE
          REPORT_URL: $REPORT_URL
          GITHUB_RUN_ID: ${{ github.run_id }}


            